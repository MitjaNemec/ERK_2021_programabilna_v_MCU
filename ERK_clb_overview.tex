% !TEX encoding = UTF-8 Unicode
\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[slovene,english]{babel}
\usepackage{sty/erk}
\usepackage{graphicx}
\usepackage[autostyle=false]{csquotes}
\usepackage[backend=biber]{biblatex}
\usepackage{times}
\usepackage[top=22.5mm, bottom=22.5mm, left=22.5mm, right=22.5mm]{geometry}

% Slike
\graphicspath{ {./fig/} }
% Literatura
\addbibresource{reference.bib}
% To avoid footnote on cover page:
\def\footnotemark{}



\begin{document}
\begin{sloppypar}
\title{Uporaba v mikrokrmilnik vgrajenih programirljivih logičnih vezij}

\author{Andrej Kenda$^{1}$}

\affiliation{$^{1}$Ime in naslov organizacije prvega avtorja}

\email{E-pošta: ak8655@student.uni-lj.si}

\maketitle



\begin{abstract}{Povzetek}
FPGA integrated circuits are often indispensable in practice, but their implementation is often demanding. In this article, we explore one of the answers to this problem offered by the manufacturer Texas Instruments. In their microcontrollers, there is an additional coprocessor, called ``CLB''. The composition of said coprocessor is described, which is essential for the use of such system.
\end{abstract}

\selectlanguage{slovene}



\section{Uvod}
Pri oblikovanju vdelanih sistemov se zaradi preprostega programiranja in
cenovne ugodnosti najpogosteje poslužujemo mikrokrmilnikov različnih
proizvajalcev. Na začetku (včasih ``celo'' na sredini) oblikovalnega procesa, v
včasih preveliki ponudbi, izberemo čip, ki najbolje ustreza našim zahtevam.

Obstajajo pa tudi aplikacije, ki jim konvencionalni mikrokrmilniki niso kos. Tu
nastopi iskanje drugačnih rešitev. Če imamo srečo, morda odkrijemo kakšen ASIC
(angl. application specific integrated circuit), ki zadošča našim potrebam,
vendar je na določenih področjih teh dokaj malo. V določenih aplikacijah nam ne
preostane drugega oz. za boljšo rešitev odkrijemo FPGA (angl. field-programable
gate array). Ti nam omogočajo postavitev sistema na nizkem nivoju, ki ga lahko
prikrojimo natanko našim zahtevam. FPGA v veliko aplikacijah namestimo poleg
prej omenjenega mikrokrmilnika in ga uporabimo kot dodaten procesor.

Kljub temu, da so FPGA čipi precej zmogljivi, pa nastopi težava pri sami
izvedbi. Kadra, ki ima globoko znanje takšnih sistemov je zaradi zahtevnosti
precej malo. Poleg tega pa uporaba dveh čipov za pri številnih aplikacijah
nemalokrat ni idealna, saj ti čipi dostikrat zahtevajo uporabo zunanjega RAM in
Flash spomina, za komunikacijo s katerima smo odgovorni sami. Razne
komunikacije med posameznimi modulil običajno terjajo največ razvojnega časa,
hkrati pa je poleg FPGA ponavadi prisoten tudi mikrokrmilnik, ki je hkrati
dodatna finančna obremenitev in še ena linija komunikacije za implementacijo.

Na naštete težave je proizvajalec Texas Instruments odgovoril s koprocesorjem
CLB (angl. configurable logic block), ki je vdelan v nekaj njihovih
mikrokrmilnikov. Ta naj bi po proizvajalčevih trditvah tako nadomestil dodaten
FPGA (in s tem razvijalcu prihranil marsikatero uro), kot tudi omogočil
programiranje s preprostim vmesnikom \cite{clb-intro}.



\section{Predstavitev CLB}\label{sec:predstavitev}
Slika \ref{fig:clb_shema} prikazuje shematski prikaz komponent v CLB
koprocesorju, ki je del mikrokrmilnika F28379D, proizvajalca Texas Instruments.
Na sliki je razvidno, da je omenjeni CLB sestavljen iz štirih med seboj enakih
podsklopov (angl. Tile). Vsak podsklop je sestavljen iz procesorja (angl. CELL)
ter vmesnika za ``priklop'' signalov iz matične naprave (angl. CPU I/F).

V CLB lahko vhodne signale pripeljemo preko treh vodil, lokalnega, globalnega
in sistemskega vodila. Teh se za vhode v CLB poslužujemo glede na samo
postavitev ostalih dodatkov, ki so poleg CLB-ja prisotni na čipu
\cite[Pogl.~26.3]{mcu-ref-manual}. Posebnost omenjenega mikrokrmilnika je tudi
prisotnost t.i. ``crossbar''-jev, ki omogočajo dovod vhodnih signalov preko
lokalnega in globalnega vodila, ter odvod signalov iz CLB-ja. Ti signali lahko
izvirajo iz različnih dodatkov, kot so eCAP, ePWM, GPIO... iz CLB-ja pa lahko v
prav te dodatke tudi ``pripeljemo'' izhodni signal iz CLB-ja, kot vhod.

Interakcija pa ni omejena le z dodatnimi napravami in matičnim procesorjem,
temveč je mogoča tudi med različnimi podsklopi CLB-ja. Možno pa je tudi
proženje prekinitev, na katere lahko procesor ustrezno reagira.

\begin{figure*}[t]
    \begin{center}
        \begin{minipage}[t]{12cm}
            \includegraphics[width=12cm]{clb_shema}
            \caption{Shematski prikaz komponent CLB koprocesorja
                     \cite[Pogl.~26.2]{mcu-ref-manual}}
            \label{fig:clb_shema}
        \end{minipage}
    \end{center}
\end{figure*}



\section{Zgradba CLB modulov}\label{sec:zgradbaclb}
V poglavju \ref{sec:predstavitev} je omeneno, da je sam CLB sestavljen iz
štirih podsklopov. Na sliki \ref{fig:clb_moduli} je videti, da vsak podsklop
vsebuje \cite[Pogl.~26.4]{mcu-ref-manual}:
\begin{itemize}
    \item 3 štirivhodne LUT4 (angl. 4-input lookup table),
    \item 8 trivhodnih izhodnih LUT3 (angl. 3-input lookup table),
    \item 3 števce,
    \item 3 FSM (angl. finite state machine),
    \item 1 HLC (angl. high level controller) in
    \item 1 nastavljiv preklopni blok.
\end{itemize}

\begin{figure*}[t]
    \begin{center}
        \begin{minipage}[t]{12cm}
            \includegraphics[width=12cm]{clb_moduli}
            \caption{Shematski prikaz komponent CLB koprocesorja
                     \cite[Pogl.~26.2]{mcu-ref-manual}}
            \label{fig:clb_moduli}
        \end{minipage}
    \end{center}
\end{figure*}

\subsection{LUT moduli}\label{sec:lut}
LUT4 modul omogoča modulacijo signala preko logičnih operacij. Vhodne signale
(slika \ref{fig:lut4} - ``IN0''-``IN3'') lahko preko enačbe z ``AND'', ``OR'',
``NOT'' in ``XOR'' operacijami odvedemo v izhodni signal
\cite[Pogl.~3.3]{clb-user-guide}.

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{shema_lut}}
    \caption{Shematski prikaz štirivhodnega LUT4 modula CLB koprocesorja
             \cite[Pogl.~26.4.4]{mcu-ref-manual}}
    \label{fig:lut4} 
\end{figure} 

Razlika med ``LUT4'' in izhodnim ``LUT3'' modulom je le, da ima slednji tri
namesto štirih vhodov, ter je njegov izhod vezan direktno na izhod CLB-ja, kar
je tudi ena izmed njegovih funkcij \cite[Pogl.~26.4.4-26.4.5]{mcu-ref-manual}.

\subsection{Števci}
Števec je precej kompleksen modul v CLB-ju, ki ga lahko nastavimo za delovanje
kot števec, seštevalnik, komparator ali operator zamika. S slike
\ref{fig:stevec} je moč razbrati štiri funkcijske vhode; ``RESET'', ``MODE 0'',
``MODE 1'' in ``EVENT''. Prvi od teh vhodnih signalov ob visoki vrednosti
števec postavi na vrednost 0, ``MODE 0'' ob visoki vrednosti omogoči štetje,
``MODE 1'' nastavi smer štetja (visoko - navzgor, nizko - navzdol), signal
``EVENT'' pa ob pozitivnem robu sproži dogodek, na katerega ta odreagira z
nastavljeno računsko operacijo, katere parametre nastavimo z drugima signaloma
(slika \ref{fig:stevec} - ``Static controls'' in ``LOAD VALUE''). Do vsebine
števca lahko dostopamo preko HLC modula (pogl. \ref{sec:hlc}), kjer je ta
označena z zaporedno številko števca (npr. števec 1 - C1).

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{shema_stevec}}
    \caption{Shematski prikaz števca CLB koprocesorja
             \cite[Pogl.~26.4.2.1]{mcu-ref-manual}}
    \label{fig:stevec} 
\end{figure} 

Kot izhod iz števca lahko spremljamo signale ``ZERO'', ``MATCH1'' in
``MATCH2''. Prvi prevzame visoko vrednost kadar je vrednost števca 0, ostala
dva pa se vklopita, kadar je vrednost števca enaka nastavljeni pripadajoči
vrednosti. Ko števec doseže svojo maksimalno vrednost ($2^{32}$) ta ``prelije''
in začne šteti od 0. Temu obnašanju se ponavadi želimo izogniti
\cite[Pogl.~26.4.2]{mcu-ref-manual}.

\subsection{FSM moduli}
FSM modul omogoča implementacijo avtomata stanj. Le to se izvede preko dveh
internih LUT blokov; ``Output LUT'', ``S0 Next State LUT'' in ``S1 Next State
LUT'' (slika \ref{fig:fsm}), te so po zgradbi povsem enake opisanim v poglavju
\ref{sec:lut}. Za implementacijo avtomata stanj uporabljamo le slednji LUT
tabeli, ki služita interni modulaciji signalov in operirata z zunanjima
signaloma ``EXT\_IN0'', ``EXT\_IN1'' in vhodoma ``S0'' in ``S1'', ki prevzameta
prejšnjo vrednost izhoda pripadajoče tabele.

Če nimamo potrebe po implemetaciji avtomata stanj, se lahko poslužimo tudi
``Output LUT'', in modul uporabimo kot običajno LUT tabelo (izhod
``FSM\_LUT\_OUT'').

Če aplikacija ne potrebuje uporabe FSM modula, se lahko poslužimo še vhodov
``EXTRA\_EXT\_IN0'' in ``EXTRA\_EXT\_IN1''. V tem primeru celoten modul deluje
kot štirivhodni LUT modul.

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{shema_fsm}}
    \caption{Shematski prikaz FSM modula CLB koprocesorja
             \cite[Pogl.~26.4.3]{mcu-ref-manual}}
    \label{fig:fsm} 
\end{figure} 

\subsection{HLC modul}\label{sec:hlc}
HLC modul je za razliko od ostale naprave veliko bolj kompleksen. S slike
\ref{fig:hlc} je iz bloka za procesiranje dogodkov in štirih registrov, ki
služijo za shranjevanje spremenljivk
``R0''-``R3''\cite[Pogl.~26.4.6]{mcu-ref-manual}.

Modul lahko direktno upravljamo tudi z matičnim procesorjem, s katerim modul
lahko komunicira tudi preko ``push-pull'' metode zapisovanja v skupni spomin.

Operiramo lahko s prej omenjenimi spremenljivkami ``R0''-``R3'', z vrednostmi
števcev ``C1''-``C2'' in z obemi ``MATCH'' vrednostmi v števcih. Za proženje
dogodkov ima modul štiri vhodne signale. Vsak od teh sproži sebi pripadajoč
program, zapisan v instrukcijskem spominu. Ta lahko na omenjenih spremenljivkah
izvede naslednje operacije \cite[Pogl.~26.4.6.2]{mcu-ref-manual}:
\begin{itemize}
    \item ADD/SUB - seštevanje in odštevanje,
    \item MOV/MOV\_T1/MOV\_T2 - premikanje,
    \item PUSH/PULL - pisanje in branje v skupnem spominu,
    \item INTR - proženje prekinitev.
\end{itemize}

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{shema_hlc}}
    \caption{Shematski prikaz HLC modula CLB koprocesorja
             \cite[Pogl.~26.4.6]{mcu-ref-manual}}
    \label{fig:hlc} 
\end{figure}

\subsection{Preklopni modul}
Ta modul je namenjen izbiri vhodnih signalov, ki lahko izvirajo iz zunanjih
virov, drugih CLB podkslopov (angl. tile) ali pa signal generira modul sam.
Zadnji vir se uporablja le za simulacijske namene. Modul je v orodju ``CLB
Tool'' (Pogl. \ref{sec:clb_tool}) zaradi postavitve predstavljen pod imenom
``BOUNDARY'' \cite[Pogl.~3.3]{clb-user-guide}.



\section{Uporaba CLB}\label{sec:clb_tool}
Za samo programiranje CLB koprocesorja v praksi je proizvajalec Texas
Instruments postavil grafični vmesnik ``CLB Tool'' (slika \ref{fig:clbtool}),
ki nam preko izbire določenih parametrov zgenerira kodo za uporabo v našem
projektu.

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{clbtool}}
    \caption{Grafično okolje ``CLB Tool''}
    \label{fig:clbtool} 
\end{figure} 

Grafični vmesnik za vsako od komponent, naštetih v poglavju
\ref{sec:zgradbaclb}, dovoljuje izbiro opisanih parametrov, vhodnih in izhodnih
signalov ter splošno konfiguracijo modulov. Kot je prikazano na sliki
\ref{fig:clbtool_struktura}, orodje generira 2 aplikacijski datoteki;
``clb\_config.h'' ter ``clb\_config.c''. Ti datoteki lahko seveda brez težav
vključimo v naš ``C'' program.

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{clbtool_struktura}}
    \caption{Struktura projekta pri uporabi orodja ``CLB Tool''
             \cite[Pogl.~1]{clb-user-guide}}
    \label{fig:clbtool_struktura} 
\end{figure} 

Poleg aplikacijske kode, pa nam orodje dovoljuje tudi generiranje simulacijskih
datotek. Te se na koncu prevedejo v datoteko ``CLB.vcd'', ki omogoča vpogled v
notranje signale CLB preko zunajega programa za prikazovanje grafov (slika
\ref{fig:clbtool_simulacija}).

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{gtkwave}}
    \caption{Pregled notranjih signalov CLB-ja s programom ``GTK Wave''}
    \label{fig:clbtool_simulacija} 
\end{figure} 

Orodje avtomatsko generira tudi datoteko za grafični pregled povezav v
koprocesorju. Ta se prevede v obliko ``.html'', ki jo lahko odpremo v vsakem
brskalniku (slika \ref{fig:clbtool_diagram})\cite[Pogl.~1]{clb-user-guide}.

\begin{figure}[htb]
    \centerline{\includegraphics[width=8cm]{html_diagram}}
    \caption{Primer generiranega ``.html'' diagrama}
    \label{fig:clbtool_diagram} 
\end{figure} 



\section{Zaključek}
Za programerja FPGA vezij so stvari, opisane v tem članku verjetno precej
domače. Lahko pa opazimo da sam CLB ni le FPGA vdelan v mikrokrmilnik, vendar
prinaša tudi nekatere novosti (npr. HLC), zaradi katerih je marsikatera
aplikacija dokaj lažja za implementacijo.

Poleg tega so na voljo tudi precej močna tudi orodja v opisanem ekosistemu.
Grafično orodje omogoča uporabo tudi manj veščim programerjem. Dodatne
generirane simulacijske datoteke pa so v veliko situacijah nepogrešljive, saj s
samim opazovanjem zunanjih signalov težko odkrijemo morebitno napako. Enako
velja za generirani diagram, ki je (če že ne drugače) uporaben za odkrivanje
napačnih in nepotrebnih povezav med posameznimi moduli v koprocesorju.

Vendar pa tudi CLB, kot vsaka stvar ne pride brez pomankljivosti. Skoraj vsaka
``izboljšava'' nad FPGA s seboj prinese tudi kakšno frustracijo za programerja;
grafični vmesnih ``CLB Tool'' je na prvi pogled res prijazen, a se zaradi
velike abstrakcije kaj hitro izgubimo med neštetimi nastavitvenimi meniji.

Kljub temu pa lahko rečemo, da je takšna izvedba dodatnega modula zelo
smiselna. Nemalokrat se znajdemo v situaciji, kjer bi bilo potrebno modulirati
nek signal, vendar je samo zanj uporaba dodatnega čipa nesmiselna. Poleg tega
pa je s stališča delodajalcev velikokrat bolj smiselno uporabiti rešitev, ki jo
lahko implementira obstoječ kader, kot pa iskanje znanja izven podjetja.



\section{Dodatno branje}
Več informacij o sami implementaciji CLB je opisanih v \cite{clb-designing}. Za
migracijo obstoječih FPGA projektov na CLB pa je precej dober uvod vir
\cite{fpga-to-clb}.



\printbibliography



\end{sloppypar}
\end{document}
